---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Add Exams - System Intelligence Benchmark">
  <div class="block">
    <div class="block-header">Default Metadata</div>
    <p style="color: var(--muted); font-size: 0.75rem; margin-bottom: 1rem;">
      These values apply to all exams uploaded in this session.
    </p>
    <div class="row">
      <div style="flex: 1;">
        <label for="default-institution">Institution</label>
        <input type="text" id="default-institution" placeholder="University of Wisconsin-Madison" />
      </div>
      <div style="flex: 1;">
        <label for="default-course">Course</label>
        <input type="text" id="default-course" placeholder="CS 537" />
      </div>
    </div>
  </div>

  <div class="block">
    <div class="block-header">Upload Exam Files</div>
    <p style="color: var(--muted); font-size: 0.75rem; margin-bottom: 1rem;">
      Upload multiple exam and solution files. AI will automatically match them and process in parallel.
    </p>
    <div class="file-input" id="files-dropzone" style="min-height: 120px;">
      <span>Click or drag to upload exam and solution files</span>
      <input type="file" id="files-input" accept=".pdf,.txt" multiple />
      <div class="file-name" id="files-list"></div>
    </div>
  </div>

  <div class="block">
    <div class="block-header">Additional Notes</div>
    <label for="notes">Notes for AI Processing</label>
    <textarea id="notes" placeholder="Any specific instructions for parsing the exams (e.g., 'Questions 1-5 are multiple choice', 'Skip questions with figures')"></textarea>
  </div>

  <button id="process-btn" style="width: 100%;">Process and Add Exam(s)</button>

  <div id="sorting-area" style="display: none;">
    <div class="block">
      <div class="block-header">File Matching</div>
      <div id="sorting-status" class="status loading">Analyzing files...</div>
      <div id="exam-groups"></div>
    </div>
  </div>

  <div id="status-area" style="display: none;">
    <div id="process-status" class="status loading">Processing...</div>
    <div id="exam-logs"></div>
  </div>

  <style>
    .exam-group {
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      background: var(--bg-secondary);
    }
    .exam-group-header {
      font-weight: 500;
      margin-bottom: 0.5rem;
      color: var(--fg);
    }
    .exam-group-files {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .exam-group-files div {
      margin: 0.25rem 0;
    }
    .exam-log {
      margin-bottom: 1rem;
    }
    .exam-log-header {
      font-weight: 500;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 4px 4px 0 0;
    }
    .exam-log-content {
      border: 1px solid var(--border);
      border-radius: 0 0 4px 4px;
      padding: 0.75rem;
      font-family: monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
      max-height: 400px;
      overflow-y: auto;
      background: var(--bg);
      line-height: 1.5;
    }
    .unmatched-files {
      margin-top: 1rem;
      padding: 0.75rem;
      border: 1px solid var(--warning, #f59e0b);
      border-radius: 4px;
      background: rgba(245, 158, 11, 0.1);
    }
    .unmatched-files-header {
      font-weight: 500;
      color: var(--warning, #f59e0b);
      margin-bottom: 0.5rem;
    }
  </style>

  <script>
    interface ExamGroup {
      exam_file: string;
      solutions_file: string;
      reference_files?: string[];
      inferred_name: string;
    }

    interface SortResult {
      exams: ExamGroup[];
      unmatched?: string[];
    }

    const filesInput = document.getElementById('files-input') as HTMLInputElement;
    const filesDropzone = document.getElementById('files-dropzone')!;
    const filesList = document.getElementById('files-list')!;
    const processBtn = document.getElementById('process-btn') as HTMLButtonElement;
    const sortingArea = document.getElementById('sorting-area')!;
    const sortingStatus = document.getElementById('sorting-status')!;
    const examGroups = document.getElementById('exam-groups')!;
    const statusArea = document.getElementById('status-area')!;
    const processStatus = document.getElementById('process-status')!;
    const examLogs = document.getElementById('exam-logs')!;

    let uploadedFiles: File[] = [];

    // File input handlers
    filesDropzone.addEventListener('click', () => filesInput.click());

    filesDropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      filesDropzone.style.borderColor = 'var(--accent)';
    });

    filesDropzone.addEventListener('dragleave', () => {
      filesDropzone.style.borderColor = 'var(--border)';
    });

    filesDropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      filesDropzone.style.borderColor = 'var(--border)';
      if (e.dataTransfer?.files) {
        addFiles(Array.from(e.dataTransfer.files));
      }
    });

    filesInput.addEventListener('change', () => {
      if (filesInput.files) {
        addFiles(Array.from(filesInput.files));
      }
    });

    function addFiles(newFiles: File[]) {
      // Add new files, avoiding duplicates
      for (const file of newFiles) {
        if (!uploadedFiles.some(f => f.name === file.name)) {
          uploadedFiles.push(file);
        }
      }
      updateFilesList();
    }

    function updateFilesList() {
      if (uploadedFiles.length > 0) {
        filesList.innerHTML = uploadedFiles.map((f, i) =>
          `<div style="display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0;">
            <span>${f.name}</span>
            <button type="button" data-index="${i}" class="remove-file" style="background: none; border: none; color: var(--muted); cursor: pointer; padding: 0 0.5rem;">&times;</button>
          </div>`
        ).join('');
        filesDropzone.classList.add('has-file');

        // Add remove handlers
        document.querySelectorAll('.remove-file').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt((e.target as HTMLElement).dataset.index || '0');
            uploadedFiles.splice(index, 1);
            updateFilesList();
          });
        });
      } else {
        filesList.innerHTML = '';
        filesDropzone.classList.remove('has-file');
      }
    }

    processBtn.addEventListener('click', async () => {
      if (uploadedFiles.length < 2) {
        alert('Please upload at least 2 files (exam and solutions).');
        return;
      }

      const apiKey = sessionStorage.getItem('openai_api_key') || '';
      const repoPath = sessionStorage.getItem('benchmark_repo_path') || '';
      const defaultInstitution = (document.getElementById('default-institution') as HTMLInputElement).value.trim();
      const defaultCourse = (document.getElementById('default-course') as HTMLInputElement).value.trim();
      const githubUsername = sessionStorage.getItem('github_username') || '';
      const githubToken = sessionStorage.getItem('github_token') || '';

      if (!apiKey) {
        alert('Please configure your OpenAI API key on the home page.');
        return;
      }

      processBtn.disabled = true;
      sortingArea.style.display = 'block';
      sortingStatus.className = 'status loading';
      sortingStatus.textContent = 'Analyzing files with AI...';
      examGroups.innerHTML = '';

      // Step 1: Sort files using AI
      let sortResult: SortResult;
      try {
        const sortResponse = await fetch('/api/exams/sort-files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            fileNames: uploadedFiles.map(f => f.name),
            apiKey
          })
        });

        if (!sortResponse.ok) {
          throw new Error('Failed to sort files');
        }

        sortResult = await sortResponse.json();

        if (!sortResult.exams || sortResult.exams.length === 0) {
          throw new Error('Could not match any exam/solution pairs');
        }

        sortingStatus.className = 'status success';
        sortingStatus.textContent = `Found ${sortResult.exams.length} exam(s)`;

        // Display matched groups
        examGroups.innerHTML = sortResult.exams.map((exam, i) => `
          <div class="exam-group">
            <div class="exam-group-header">Exam ${i + 1}: ${exam.inferred_name}</div>
            <div class="exam-group-files">
              <div><strong>Questions:</strong> ${exam.exam_file}</div>
              <div><strong>Solutions:</strong> ${exam.solutions_file}</div>
              ${exam.reference_files?.length ? `<div><strong>References:</strong> ${exam.reference_files.join(', ')}</div>` : ''}
            </div>
          </div>
        `).join('');

        // Show unmatched files if any
        if (sortResult.unmatched && sortResult.unmatched.length > 0) {
          examGroups.innerHTML += `
            <div class="unmatched-files">
              <div class="unmatched-files-header">Unmatched Files</div>
              <div style="font-size: 0.75rem; color: var(--muted);">
                ${sortResult.unmatched.join(', ')}
              </div>
            </div>
          `;
        }

      } catch (error) {
        sortingStatus.className = 'status error';
        sortingStatus.textContent = `Error: ${error}`;
        processBtn.disabled = false;
        return;
      }

      // Step 2: Process all exams in parallel
      statusArea.style.display = 'block';
      processStatus.className = 'status loading';
      processStatus.textContent = `Processing ${sortResult.exams.length} exam(s) in parallel...`;

      const notes = (document.getElementById('notes') as HTMLTextAreaElement).value.trim();

      // Create log containers for each exam
      examLogs.innerHTML = sortResult.exams.map((exam, i) => `
        <div class="exam-log" id="exam-log-${i}">
          <div class="exam-log-header">${exam.inferred_name}</div>
          <div class="exam-log-content" id="exam-log-content-${i}">Starting...</div>
        </div>
      `).join('');

      // Process all exams in parallel
      const processPromises = sortResult.exams.map(async (exam, index) => {
        const logContent = document.getElementById(`exam-log-content-${index}`)!;

        try {
          const examFile = uploadedFiles.find(f => f.name === exam.exam_file);
          const solutionsFile = uploadedFiles.find(f => f.name === exam.solutions_file);
          const referenceFiles = exam.reference_files?.map(name => uploadedFiles.find(f => f.name === name)).filter(Boolean) as File[] || [];

          if (!examFile || !solutionsFile) {
            throw new Error('Could not find matched files');
          }

          const formData = new FormData();
          formData.append('examFile', examFile);
          formData.append('solutionsFile', solutionsFile);
          formData.append('notes', notes);
          formData.append('apiKey', apiKey);

          if (repoPath) formData.append('repoPath', repoPath);
          if (defaultInstitution) formData.append('institution', defaultInstitution);
          if (defaultCourse) formData.append('course', defaultCourse);
          if (githubUsername) formData.append('githubUsername', githubUsername);
          if (githubToken) formData.append('githubToken', githubToken);

          for (const ref of referenceFiles) {
            formData.append('referenceFiles', ref);
          }

          const response = await fetch('/api/exams/process', {
            method: 'POST',
            body: formData
          });

          const reader = response.body?.getReader();
          const decoder = new TextDecoder();
          let firstChunk = true;

          if (reader) {
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              const text = decoder.decode(value);
              if (firstChunk) {
                logContent.textContent = text; // Clear "Starting..." on first chunk
                firstChunk = false;
              } else {
                logContent.textContent += text;
              }
              logContent.scrollTop = logContent.scrollHeight;
            }
          }

          return { index, success: response.ok, name: exam.inferred_name };
        } catch (error) {
          logContent.textContent += `\nERROR: ${error}`;
          return { index, success: false, name: exam.inferred_name, error };
        }
      });

      const results = await Promise.all(processPromises);
      const successCount = results.filter(r => r.success).length;
      const failCount = results.length - successCount;

      if (failCount === 0) {
        processStatus.className = 'status success';
        processStatus.textContent = `All ${successCount} exam(s) processed successfully!`;
      } else if (successCount === 0) {
        processStatus.className = 'status error';
        processStatus.textContent = `All ${failCount} exam(s) failed to process`;
      } else {
        processStatus.className = 'status warning';
        processStatus.textContent = `${successCount} exam(s) succeeded, ${failCount} failed`;
      }

      processBtn.disabled = false;
    });
  </script>
</Layout>
